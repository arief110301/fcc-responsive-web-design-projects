<!DOCTYPE html>
<html>
    <head>
        <title>Important Features of ES6</title>

        <link rel="shortcut icon" href="favicon.ico">
        <link rel="stylesheet" href="style.css">
        <link rel="stylesheet" href="normalize.css">
    </head>
    <body>
        <div class="container">
            <nav id="navbar">
                <header>Important <div id="ES6">ES6</div> Features</header>
                <ul>
                    <li><a class="nav-link" href="#Introduction">Introduction</a></li>
                    <li><a class="nav-link" href="#let_and_const_keywords">let and const keywords</a></li>
                    <li><a class="nav-link" href="#Arrow_functions">Arrow functions</a></li>
                    <li><a class="nav-link" href="#Default_parameters">Default parameters</a></li>
                    <li><a class="nav-link" href="#Rest_operator">Rest operator</a></li>
                    <li><a class="nav-link" href="#Spread_operator">Spread operator</a></li>
                    <li><a class="nav-link" href="#Destructuring_assignment">Destructuring assignment</a></li>
                    <li><a class="nav-link" href="#Template_literals">Template literals</a></li>
                    <li><a class="nav-link" href="#Class_keyword">Class keyword</a></li>
                    <li><a class="nav-link" href="#Modules">Modules</a></li>
                    <li><a class="nav-link" href="#Promises">Promises</a></li>
                </ul>
            </nav>
            <main id="main-doc">
                <section class="main-section" id="Introduction">
                    <header>Introduction</header>
                    <p>ECMAScript 6 is also known as ES6 and ECMAScript 2015. Some people call it JavaScript 6.</p>
                    <p>ECMAScript is a scripting-language specification. It was created to standardize JavaScript to help foster multiple independent implementations.</p>
                    <p>The first edition of ECMA-262 was adopted by the Ecma General Assembly in June 1997. Several editions of the language standard have been published since then. The name "ECMAScript" was a compromise between the organizations involved in standardizing the language, especially Netscape and Microsoft, whose disputes dominated the early standards sessions.</p>
                    <p>There are ten editions of ECMA-262 published. Work on version 10 of the standard was finalized in June 2019. Version 6 was finalized in June 2015.</p>
                    <cite>-<a href="https://en.wikipedia.org/wiki/ECMAScript">Wikipedia</a></cite>
                    <p>This documentation of ES6 does not cover all of the features. I picked the topics I find most relevant to my experience in coding with JavaScript. The content of these sections are a remix of the ES6 lessons by <a href="https://www.freecodecamp.org/">FreeCodeCamp</a>.</p>
                </section>
                <section class="main-section" id="let_and_const_keywords">
                    <header>let and const keywords</header>
                    <p>One of the biggest problems with declaring variables with the var keyword is that you can overwrite variable declarations without an error.</p>
                    <code>
                        var camper = 'James'; <br>
                        var camper = 'David'; <br>
                        console.log(camper); 
                        // logs 'David'
                    </code>
                    <p>A new keyword called let was introduced in ES6 to solve this potential issue with the var keyword. If you were to replace var with let in the variable declarations of the code above, the result would be an error.</p>
                    <code>
                        let camper = 'James'; <br>
                        let camper = 'David'; // throws an error
                    </code>
                    <p>Also, when you declare a variable with the let keyword inside a block, statement, or expression, its scope is limited to that block, statement, or expression.</p>
                    <code>
                        let num = 0; <br>
                        for (let i = 1; i < 3; i++) { <br>
                        num += i; <br>
                        } <br>
                        console.log(i); // returns "i is not defined" <br>
                        consosle.log(num); // returns 3
                    </code>
                    <hr>
                    <p>const has all the awesome features that let has (block-scoping), with the added bonus that variables declared using const are read-only. They are a constant value, which means that once a variable is assigned with const, it cannot be reassigned.</p>
                    <code>
                            const FAV_PET = "Cats"; <br>
                            FAV_PET = "Dogs"; // returns error
                    </code>
                    <p> A common practice when naming constants is to use all uppercase letters, with words separated by an underscore.</p>
                    <p>it is important to understand that objects (including arrays and functions) assigned to a variable using const are still mutable. Using the const declaration only prevents reassignment of the variable identifier.</p>
                    <code>
                        const s = [5, 6, 7]; <br>
                        s = [1, 2, 3]; // throws error, trying to assign a const <br>
                        s[2] = 45; // works just as it would with an array declared with var or let <br>
                        console.log(s); // returns [5, 6, 45]
                    </code>
                    <hr>
                    <p>Hoisting is JavaScript's default behavior of moving declarations to the top. JavaScript only hoists declarations, not initializations. If a variable is declared and initialized after using it, the value will be undefined. Variables declared with the following are hoisted:</p>
                    <ul>
                        <li>var</li>
                        <li>class</li>
                        <li>function</li>
                    </ul>
                    <p>Variables and constants declared with the following are not hoisted and are not initialized until their definition is evaluated:</p>
                    <ul>
                        <li>let</li>
                        <li>const</li>
                    </ul>
                </section>
                <section class="main-section" id="Arrow_functions">
                    <header>Arrow functions</header>
                    <p>Arrow functions simplify your syntax and cut down on the overall amount of code you need to write for a function.</p>
                    <code>
                        const myFunc = function() { <br>
                            const myVar = "value"; <br>
                            return myVar; <br>
                        }
                    </code>
                    <p>Take a look at the new ES6 syntactic sugar to write functions.</p>
                    <code>
                        const myFunc = () => { <br>
                            const myVar = "value"; <br>
                            return myVar; <br>
                        }                        
                    </code>
                    <p>Also, arrow functions keep 'this' from changing. It will remain in the same scope as the function using it, making it much more effective for DOM interactions, like button presses.</p>
                    <p>We can stop using that = this or self = this or _this = this or .bind(this)</p>
                </section>
                <section class="main-section" id="Default_parameters">
                    <header>Default parameters</header>
                    <p>Default parameters kick in when the argument is not specified (it is undefined). </p>
                    <p>In ES5, we were using logic OR operator.</p>
                    <code>
                        var calculateArea = function(height, width) {  <br>
                            height =  height || 50; <br>
                            width = width || 80; <br>
                            // logic <br>
                        }
                    </code>
                    <p>In ES6, we can put the default values right in the signature of the functions.</p>
                    <code>
                        const greeting = (name = "Anonymous") => { <br>
                        return "Hello " + name; <br>
                        } <br>
                        console.log(greeting("John")); // Hello John <br>
                        console.log(greeting()); // Hello Anonymous
                    </code>
                    <p>You can add default values for as many parameters as you want.</p>
                </section>
                <section class="main-section" id="Rest_operator">
                    <header>Rest operator</header>
                    <p>With the rest parameter, you can create functions that take a variable number of arguments. These arguments are stored in an array that can be accessed later from inside the function.</p>
                    <code>
                        const sum = (...args) => { <br>
                            return args.reduce((a, b) => a + b, 0); <br>
                        } <br>
                        console.log(sum(1, 2, 3)); // 6
                    </code>
                    <p>The rest parameter eliminates the need to check the args array and allows us to apply map(), filter() and reduce() on the parameters array.</p>
                </section>
                <section class="main-section" id="Spread_operator">
                    <header>Spread operator</header>
                    <p>ES6 introduces the spread operator, which allows us to expand arrays and other expressions in places where multiple parameters or elements are expected.</p>
                    <p>In ES5, we would have to use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply method</a> from the Function prototype.</p>
                    <code>
                        var arr = [6, 89, 3, 45]; <br>
                        var maximus = Math.max.apply(null, arr); // returns 89
                    </code>
                    <p>Here is the same thing but in ES6. The spread operator makes this syntax much better to read and maintain.</p>
                    <code>
                        const arr = [6, 89, 3, 45]; <br>
                        const maximus = Math.max(...arr); // returns 89
                    </code>
                    <p>...arr returns an unpacked array. In other words, it spreads the array. </p>
                    <p>However, the spread operator only works in-place, like in an argument to a function or in an array literal.</p>
                </section>
                <section class="main-section" id="Destructuring_assignment">
                    <header>Destructuring assignment</header>
                    <p>The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variable.</p>
                    <p>In ES5, we had to use below approach.</p>
                    <code>
                        const user = { name: 'John Doe', age: 34 }; <br>

                        const name = user.name; // name = 'John Doe' <br>
                        const age = user.age; // age = 34 
                    </code>
                    <p>
                        In ES6, we can replace the ES5 code above with this:
                    </p>
                    <code>
                        const { name, age } = user; <br>
                        // name = 'John Doe', age = 34
                    </code>
                    <hr>
                    <p>Destructuring allows you to assign a new variable name when extracting values. You can do this by putting the new name after a colon when assigning the value.</p>
                    <p>Using the same object from the last example:</p>
                    <code>const user = { name: 'John Doe', age: 34 };</code>
                    <p>Here's how you can give new variable names in the assignment:</p>
                    <code>
                        const { name: userName, age: userAge } = user; <br>
                        // userName = 'John Doe', userAge = 34
                    </code>
                    <hr>
                    <p>Destructuring also works for arrays.</p>
                    <p>One key difference between the spread operator and array destructuring is that the spread operator unpacks all contents of an array into a comma-separated list. Consequently, you cannot pick or choose which elements you want to assign to variables.</p>
                    <code>
                        const [a, b] = [1, 2, 3, 4, 5, 6]; <br>
                        console.log(a, b); // 1, 2
                    </code>
                    <p>We can also access the value at any index in an array with destructuring by using commas to reach the desired index:</p>
                    <code>
                        const [a, b,,, c] = [1, 2, 3, 4, 5, 6]; <br>
                        console.log(a, b, c); // 1, 2, 5
                    </code>
                    <hr>
                    <p>In some situations involving array destructuring, we might want to collect the rest of the elements into a separate array.</p>
                    <p>The result is similar to Array.prototype.slice().</p>
                    <code>
                        const [a, b, ...arr] = [1, 2, 3, 4, 5, 7]; <br>
                        console.log(a, b); // 1, 2 <br>
                        console.log(arr); // [3, 4, 5, 7]
                    </code>
                    <hr>
                    <p>In some cases, you can destructure the object in a function argument itself.</p>
                    <p>Consider the code below:</p>
                    <code>
                        const profileUpdate = (profileData) => { <br>
                            const { name, age, nationality, location } = profileData; <br>
                            // do something with these variables <br>
                        }
                    </code>
                    <p>This effectively destructures the object sent into the function. This can also be done in-place:</p>
                    <code>
                        const profileUpdate = ({ name, age, nationality, location }) => { <br>
                            /* do something with these fields */ <br>
                        }
                    </code>
                </section>
                <section class="main-section" id="Template_literals">
                    <header>Template literals</header>
                    <p>The template literal is a special type of string that makes creating complex strings easier.</p>
                    <p> Prior to ES6, you needed to rely on somewhat messy string concatenation to achieve a similar effect, and the resulting code was anything but clean.</p>
                    <code>var greeting = "Hello " + first + " " + last +"! Welcome back!";</code>
                    <p>In ES6, we can use a new syntax ${PARAMETER} inside of the back-ticked string.</p>
                    <code>let greeting = "Hello ${first} ${last}! Welcome back!";</code>
                    <p>Also, template literals allow you to create multi-line strings and to use string interpolation features to create strings.</p>
                </section>
                <section class="main-section" id="Class_keyword">
                    <header>Class keyword</header>
                    <p>ES6 provides a new syntax to help create objects, using the keyword class.</p>
                    <p>In ES5, we usually define a constructor function, and use the new keyword to instantiate an object.</p>
                    <code>
                        var SpaceShuttle = function(targetPlanet){ <br>
                            this.targetPlanet = targetPlanet; <br>
                        } <br>
                        var zeus = new SpaceShuttle('Jupiter'); <br>
                    </code>
                    <p>The class syntax simply replaces the constructor function creation:</p>
                    <code>
                        class SpaceShuttle { <br>
                            constructor(targetPlanet) { <br>
                                this.targetPlanet = targetPlanet; <br>
                            } <br>
                        } <br>
                        const zeus = new SpaceShuttle('Jupiter');
                    </code>
                    <p><strong>Note: </strong>UpperCamelCase should be used by convention for ES6 class names, as in SpaceShuttle used above.</p>
                </section>
                <section class="main-section" id="Modules">
                    <header>Modules</header>
                    <p>In order to make JavaScript more modular, clean, and maintainable; ES6 introduced a way to easily share code among JavaScript files. This involves exporting parts of a file for use in one or more other files, and importing the parts you need, where you need them. Such a file requires a script in your HTML document with a type of module.</p>
                    <code>
                            &lt;script type="module" src="filename.js">
                    </code>
                    <hr>
                    <p>If you want to use a function in several different JavaScript files, you need to first export it.</p>
                    <code>
                        export const add = (x, y) => { <br>
                            return x + y; <br>
                        }
                    </code>
                    <p>The above is a common way to export a single function, but you can achieve the same thing like this:</p>
                    <code>
                        const add = (x, y) => { <br>
                            return x + y; <br>
                        } <br> 
                        export { add }; <br>
                    </code>
                    <hr>
                    <p>import allows you to choose which parts of a file or module to load. In the previous lesson</p>
                    <code>
                        import { add, subtract } from './math_functions.js';
                    </code>
                    <p>Here, import will find add in math_functions.js, import just that function for you to use, and ignore the rest. The ./ tells the import to look for the math_functions.js file in the same folder as the current file. The relative file path (./) and file extension (.js) are required when using import in this way.</p>
                    <hr>
                    <p>Suppose you have a file and you wish to import all of its contents into the current file. This can be done with the import * as syntax.</p>
                    <code>import * as myMathModule from "./math_functions.js";</code>
                    <p>The above import statement will create an object called myMathModule. This is just a variable name, you can name it anything.</p>
                    <p>Here's how you can use the add and subtract functions that were imported:</p>
                    <code>
                        myMathModule.add(2,3); <br>
                        myMathModule.subtract(5,3);
                    </code>
                    <hr>
                    <p>There is another export syntax you need to know, known as <em>>export default</em>.</p>
                    <p>Usually you will use this syntax if only one value is being exported from a file. It is also used to create a fallback value for a file or module.</p>
                    <code>
                        // named function <br>
                        export default function add(x, y) { <br>
                            return x + y; <br>
                        } <br>
                        
                        // anonymous function <br>
                        export default function(x, y) { <br>
                            return x + y; <br>
                        } 
                    </code>
                    <p>Since export default is used to declare a fallback value for a module or file, you can only have one value be a default export in each module or file. Additionally, you cannot use export default with var, let, or const</p>
                    <hr>
                    <p>To import a default export, you need to use a different import syntax.</p>
                    <code>import add from "./math_functions.js";</code>
                    <p>The syntax differs in one key place. The imported value, add, is not surrounded by curly braces ({}). add here is simply a variable name for whatever the default export of the math_functions.js file is.</p>
                </section>
                <section class="main-section" id="Promises">
                    <header>Promises</header>
                    <p>A promise in JavaScript is exactly what it sounds like - you use it to make a promise to do something, usually asynchronously. When the task completes, you either fulfill your promise or fail to do so. </p>
                    <p>Promise is a constructor function, so you need to use the new keyword to create one. It takes a function, as its argument, with two parameters - resolve and reject. These are methods used to determine the outcome of the promise. The syntax looks like this:</p>
                    <code>
                        const myPromise = new Promise((resolve, reject) => { <br>

                        });
                    </code>
                    <p>A promise has three states: pending, fulfilled, and rejected. The promise you created in the last challenge is forever stuck in the pending state because you did not add a way to complete the promise. The resolve and reject parameters given to the promise argument are used to do this. resolve is used when you want your promise to succeed, and reject is used when you want it to fail. These are methods that take an argument, as seen below.</p>
                    <code>
                        const myPromise = new Promise((resolve, reject) => { <br>
                            if(condition here) { <br>
                                resolve("Promise was fulfilled"); <br>
                            } else { <br>
                                reject("Promise was rejected"); <br>
                            } <br>
                        });
                    </code>
                    <p>The example above uses strings for the argument of these functions, but it can really be anything. Often, it might be an object, that you would use data from, to put on your website or elsewhere.</p>
                    <hr>
                    <p>Promises are most useful when you have a process that takes an unknown amount of time in your code (i.e. something asynchronous), often a server request. When you make a server request it takes some amount of time, and after it completes you usually want to do something with the response from the server. This can be achieved by using the then method. The then method is executed immediately after your promise is fulfilled with resolve. Here’s an example:</p>
                    <code>
                        myPromise.then(result => { <br>
                            // do something with the result. <br>
                        });
                    </code>
                    <p>result comes from the argument given to the resolve method.</p>
                    <hr>
                    <p>catch is the method used when your promise has been rejected. It is executed immediately after a promise's reject method is called. Here’s the syntax:</p>
                    <code>
                        myPromise.catch(error => { <br>
                            // do something with the error. <br>
                        });
                    </code>
                    <p>error is the argument passed in to the reject method.</p>
                    <p><strong>Note: </strong>the then and catch methods can be chained to the promise declaration if you choose.</p>
                </section>
            </main>
        </div>
    </body>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</html>